5789
((3) 0 () 25 ((q lib "rosette/base/base.rkt") (q lib "rosette/base/core/term.rkt") (q lib "rosette/base/core/bool.rkt") (q lib "rosette/solver/solution.rkt") (q lib "rosette/solver/solver.rkt") (q 1414 . 5) (q 3781 . 16) (q 3585 . 7) (q 2283 . 28) (q lib "rosette/base/core/type.rkt") (q 5393 . 7) (q lib "rosette/query/form.rkt") (q 1653 . 7) (q 3255 . 10) (q lib "rosette/base/core/function.rkt") (q 1516 . 7) (q lib "rosette/base/form/define.rkt") (q lib "rosette/lib/synthax/core.rkt") (q lib "rosette/base/core/union.rkt") (q lib "rosette/base/core/forall.rkt") (q 3060 . 7) (q 4395 . 7) (q lib "rosette/lib/synthax/form.rkt") (q lib "rosette/query/debug.rkt") (q 4565 . 5)) () (h ! (equal) ((c def c (c (? . 0) q bvlshr)) c (? . 13)) ((c def c (c (? . 0) q bvsub)) c (? . 7)) ((c form c (c (? . 16) q define-symbolic*)) q (83 . 4)) ((c def c (c (? . 0) q bitvector?)) q (1954 . 3)) ((c def c (c (? . 0) q bv?)) q (2234 . 3)) ((c def c (c (? . 1) q clear-terms!)) q (8300 . 3)) ((c def c (c (? . 9) q solvable?)) q (7657 . 3)) ((c def c (c (? . 0) q bvsgt)) c (? . 8)) ((c form c (c (? . 1) q expression)) q (7485 . 2)) ((c form c (c (? . 2) q with-asserts)) q (8195 . 2)) ((c form c (c (? . 19) q for*/all)) q (7920 . 2)) ((c def c (c (? . 2) q clear-asserts!)) q (8157 . 2)) ((c def c (c (? . 0) q ||)) c (? . 5)) ((c def c (c (? . 3) q solution?)) q (5879 . 3)) ((c def c (c (? . 4) q solver-shutdown)) q (5781 . 3)) ((c def c (c (? . 3) q unknown)) q (6335 . 2)) ((q def ((lib "rosette/lib/angelic.rkt") choose*)) q (7122 . 3)) ((c def c (c (? . 4) q solver-maximize)) c (? . 10)) ((c def c (c (? . 3) q unsat)) q (6233 . 4)) ((c def c (c (? . 0) q bvurem)) c (? . 6)) ((c def c (c (? . 0) q extract)) q (4267 . 5)) ((c def c (c (? . 0) q &&)) c (? . 5)) ((c def c (c (? . 3) q model)) q (6369 . 3)) ((c def c (c (? . 0) q bvsrem)) c (? . 6)) ((c def c (c (? . 0) q bvadd)) c (? . 7)) ((c def c (c (? . 0) q bvudiv)) c (? . 6)) ((c def c (c (? . 0) q bveq)) c (? . 8)) ((c def c (c (? . 0) q bvule)) c (? . 8)) ((c def c (c (? . 4) q solver?)) q (5153 . 3)) ((c form c (c (? . 11) q verify)) q (315 . 3)) ((c def c (c (? . 0) q bvugt)) c (? . 8)) ((c form c (c (? . 22) q ??)) q (6658 . 7)) ((c def c (c (? . 9) q type?)) q (7606 . 3)) ((c def c (c (? . 14) q fv?)) q (4976 . 3)) ((c def c (c (? . 0) q concat)) q (4216 . 3)) ((c def c (c (? . 0) q forall)) c (? . 12)) ((c def c (c (? . 1) q term?)) q (7293 . 3)) ((c def c (c (? . 4) q solver-check)) q (5639 . 3)) ((c def c (c (? . 4) q solver-assert)) q (5206 . 4)) ((c def c (c (? . 3) q unsat?)) q (6000 . 3)) ((c form c (c (? . 17) q define-synthax)) q (6822 . 6)) ((c def c (c (? . 0) q bv)) q (2010 . 5)) ((c def c (c (? . 4) q solver-minimize)) c (? . 10)) ((c def c (c (? . 0) q sign-extend)) c (? . 21)) ((q def ((lib "rosette/solver/smt/z3.rkt") z3)) q (5851 . 2)) ((c form c (c (? . 1) q constant)) q (7522 . 2)) ((c form c (c (? . 11) q solve)) q (294 . 2)) ((q def ((lib "rosette/query/finitize.rkt") current-bitwidth)) q (1160 . 5)) ((c def c (c (? . 3) q unknown?)) q (6060 . 3)) ((c def c (c (? . 1) q expression?)) q (7344 . 3)) ((c def c (c (? . 0) q bvsmod)) c (? . 6)) ((c def c (c (? . 0) q distinct?)) q (1304 . 3)) ((c def c (c (? . 0) q bvsge)) c (? . 8)) ((c def c (c (? . 0) q bvxor)) c (? . 20)) ((c def c (c (? . 0) q bvslt)) c (? . 8)) ((c def c (c (? . 1) q constant?)) q (7401 . 3)) ((c def c (c (? . 0) q <=>)) c (? . 15)) ((c def c (c (? . 4) q solver-debug)) q (5710 . 3)) ((c def c (c (? . 0) q exists)) c (? . 12)) ((c def c (c (? . 18) q union-contents)) q (7764 . 4)) ((q form ((lib "rosette/lib/lift.rkt") define-lift)) q (7968 . 3)) ((c def c (c (? . 0) q bvashr)) c (? . 13)) ((c def c (c (? . 14) q ~>)) q (4781 . 4)) ((c def c (c (? . 0) q bvneg)) q (3519 . 3)) ((c def c (c (? . 0) q bvmul)) c (? . 7)) ((c def c (c (? . 2) q pc)) q (8084 . 2)) ((c def c (c (? . 4) q gen:solver)) q (5124 . 2)) ((c def c (c (? . 0) q =>)) c (? . 15)) ((c form c (c (? . 16) q define-symbolic)) q (0 . 4)) ((c def c (c (? . 0) q bvsdiv)) c (? . 6)) ((c def c (c (? . 17) q generate-forms)) q (6963 . 3)) ((c def c (c (? . 0) q bvnot)) q (2994 . 3)) ((c def c (c (? . 3) q sat)) q (6122 . 4)) ((c form c (c (? . 23) q debug)) q (1063 . 4)) ((c def c (c (? . 18) q union?)) q (7712 . 3)) ((c form c (c (? . 19) q for/all)) q (7879 . 2)) ((c def c (c (? . 3) q core)) q (6468 . 3)) ((c def c (c (? . 1) q term-cache)) q (8223 . 4)) ((c def c (c (? . 0) q bvand)) c (? . 20)) ((c def c (c (? . 4) q solver-clear)) q (5326 . 3)) ((c form c (c (? . 11) q synthesize)) q (408 . 10)) ((c form c (c (? . 1) q term)) q (7456 . 2)) ((q form ((lib "rosette/base/core/safe.rkt") assert)) q (167 . 7)) ((c def c (c (? . 0) q !)) q (1364 . 3)) ((c def c (c (? . 0) q bvor)) c (? . 20)) ((c def c (c (? . 9) q type-of)) q (7550 . 3)) ((c def c (c (? . 0) q bitvector)) q (1835 . 3)) ((c def c (c (? . 0) q bvsle)) c (? . 8)) ((c def c (c (? . 0) q bvuge)) c (? . 8)) ((c def c (c (? . 2) q asserts)) q (8113 . 2)) ((c def c (c (? . 17) q print-forms)) q (7050 . 3)) ((q def ((lib "rosette/query/core.rkt") current-solver)) q (5025 . 4)) ((c def c (c (? . 0) q bvshl)) c (? . 13)) ((c def c (c (? . 0) q bitvector->natural)) c (? . 24)) ((q def ((lib "rosette/query/eval.rkt") evaluate)) q (6575 . 4)) ((c def c (c (? . 3) q sat?)) q (5942 . 3)) ((c form c (c (? . 11) q optimize)) q (611 . 14)) ((q def ((lib "rosette/lib/render.rkt") render)) q (7178 . 4)) ((c def c (c (? . 0) q zero-extend)) c (? . 21)) ((c form c (c (? . 22) q choose)) q (6794 . 2)) ((c def c (c (? . 0) q integer->bitvector)) q (4679 . 4)) ((c def c (c (? . 0) q bvult)) c (? . 8)) ((c def c (c (? . 14) q function?)) q (4921 . 3)) ((c form c (c (? . 23) q define/debug)) q (989 . 5)) ((c def c (c (? . 0) q bitvector->integer)) c (? . 24))))
syntax
(define-symbolic id ...+ type)
 
  type : (and/c solvable? type?)
syntax
(define-symbolic* id ...+ type)
 
  type : (and/c solvable? type?)
syntax
(assert expr maybe-message)
 
maybe-message = 
              | expr
 
  expr : (or/c string? procedure?)
syntax
(solve expr)
syntax
(verify guarantee-expr)
(verify #:assume assume-expr #:guarantee guarantee-expr)
syntax
(synthesize
   #:forall input-expr
   maybe-assume
   #:guarantee guarantee-expr)
 
maybe-assume = 
             | #:assume assume-expr
 
  input-expr : (listof constant?)
syntax
(optimize
   maybe-minimize
   maybe-maximize
   #:guarantee guarantee-expr)
 
maybe-minimize = 
               | #:minimize minimize-expr
                  
maybe-maximize = 
               | #:maximize maximize-expr
 
  minimize-expr : (listof (or/c integer? real? bv?))
  maximize-expr : (listof (or/c integer? real? bv?))
syntax
(define/debug head body ...)
 
head = id
     | (id ...)
syntax
(debug [type ...+] expr)
 
  type : (and/c solvable? type? (not/c function?))
parameter
(current-bitwidth) -> (or/c #f positive-integer?)
(current-bitwidth k) -> void?
  k : (or/c #f positive-integer?)
 = 5
procedure
(distinct? v ...) -> boolean?
  v : any/c
procedure
(! v) -> boolean?
  v : boolean?
procedure
(&& v ...) -> boolean?
  v : boolean?
(|| v ...) -> boolean?
  v : boolean?
procedure
(=> x y) -> boolean?
  x : boolean?
  y : boolean?
(<=> x y) -> boolean?
  x : boolean?
  y : boolean?
procedure
(forall vs body) -> boolean?
  vs : (listof constant?)
  body : boolean?
(exists vs body) -> boolean?
  vs : (listof constant?)
  body : boolean?
procedure
(bitvector size) -> bitvector?
  size : (and/c integer? positive? (not/c term?) (not/c union?))
procedure
(bitvector? v) -> boolean?
  v : any/c
procedure
(bv val size) -> bv?
  val : (and/c integer? (not/c term?) (not/c union?))
  size : (and/c (or/c bitvector? (and/c integer? positive?))
                (not/c term?) (not/c union?))
procedure
(bv? v) -> boolean?
  v : any/c
procedure
(bveq x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvslt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvult x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsle x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvule x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsgt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvugt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvuge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvnot x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvand x ...+) -> (bitvector n)
  x : (bitvector n)
(bvor x ...+) -> (bitvector n)
  x : (bitvector n)
(bvxor x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvshl x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvlshr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvashr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvneg x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvadd x ...+) -> (bitvector n)
  x : (bitvector n)
(bvsub x ...+) -> (bitvector n)
  x : (bitvector n)
(bvmul x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvsdiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvudiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsrem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvurem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsmod x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(concat x ...+) -> bv?
  x : bv?
procedure
(extract i j x) -> (bitvector (+ 1 (- i j)))
  i : integer?
  j : integer?
  x : (bitvector n)
procedure
(sign-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
(zero-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
procedure
(bitvector->integer x) -> integer?
  x : bv?
(bitvector->natural x) -> integer?
  x : bv?
procedure
(integer->bitvector i t) -> bv?
  i : integer?
  t : (or/c bitvector? union?)
procedure
(~> d ...+ r) -> function?
  d : (and/c solvable? (not/c function?))
  r : (and/c solvable? (not/c function?))
procedure
(function? v) -> boolean?
  v : any/c
procedure
(fv? v) -> boolean?
  v : any/c
parameter
(current-solver) -> solver?
(current-solver solver) -> void?
  solver : solver?
value
gen:solver : solver?
procedure
(solver? v) -> boolean?
  v : any/c
procedure
(solver-assert solver constraints) -> void?
  solver : solver?
  constraints : (listof boolean?)
procedure
(solver-clear solver) -> void?
  solver : solver?
procedure
(solver-minimize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
(solver-maximize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
procedure
(solver-check solver) -> solution?
  solver : solver?
procedure
(solver-debug solver) -> solution?
  solver : solver?
procedure
(solver-shutdown solver) -> void?
  solver : solver?
procedure
(z3) -> solver?
procedure
(solution? value) -> boolean?
  value : any/c
procedure
(sat? value) -> boolean?
  value : any/c
procedure
(unsat? value) -> boolean?
  value : any/c
procedure
(unknown? value) -> boolean?
  value : any/c
procedure
(sat) -> sat?
(sat binding) -> sat?
  binding : (hash/c constant? any/c #:immutable #t)
procedure
(unsat) -> unsat?
(unsat constraints) -> unsat?
  constraints : (listof boolean?)
procedure
(unknown) -> unknown?
procedure
(model solution) -> (hash/c constant? any/c #:immutable #t)
  solution : sat?
procedure
(core solution) -> (or/c (listof (and/c constant? boolean?)) #f)
  solution : unsat?
procedure
(evaluate v solution) -> any/c
  v : any/c
  solution : sat?
syntax
(?? maybe-type)
 
maybe-type = 
           | type-expr
 
  type-expr : (and/c solvable? type? (not/c function?))
syntax
(choose expr ...+)
syntax
(define-synthax id
  ([pattern expr] ...+))
(define-synthax (id terminal ... k)
  #:base base-expr
  #:else else-expr)
procedure
(generate-forms solution) -> (listof syntax?)
  solution : solution?
procedure
(print-forms solution) -> void?
  solution : solution?
procedure
(choose* v ...+) -> any/c
  v : any/c
procedure
(render solution [font-size]) -> pict?
  solution : solution?
  font-size : natural/c = 16
procedure
(term? v) -> boolean?
  v : any/c
procedure
(expression? v) -> boolean?
  v : any/c
procedure
(constant? v) -> boolean?
  v : any/c
syntax
(term content type)
syntax
(expression op child ...+)
syntax
(constant id type)
procedure
(type-of v ...+) -> type?
  v : any/c
procedure
(type? v) -> boolean?
  v : any/c
procedure
(solvable? v) -> boolean?
  v : any/c
procedure
(union? v) -> boolean?
  v : any/c
procedure
(union-contents u)
 -> (listof (cons/c (and/c boolean? term?) (not/c union?)))
  u : union?
syntax
(for/all ([id val-expr]) body)
syntax
(for*/all ([id val-expr] ...+) body)
syntax
(define-lift id [(arg-type ...) racket-procedure-id])
(define-lift id [arg-type racket-procedure-id])
procedure
(pc) -> boolean?
procedure
(asserts) -> (listof boolean?)
procedure
(clear-asserts!) -> void?
syntax
(with-asserts expr)
parameter
(term-cache) -> hash?
(term-cache h) -> void?
  h : hash?
procedure
(clear-terms! [terms]) -> void?
  terms : (or/c #f (listof term?)) = #f
