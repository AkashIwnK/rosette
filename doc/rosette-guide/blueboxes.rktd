5322
((3) 0 () 22 ((q lib "rosette/base/base.rkt") (q lib "rosette/base/core/term.rkt") (q lib "rosette/query/form.rkt") (q lib "rosette/solver/solver.rkt") (q lib "rosette/solver/solution.rkt") (q 3250 . 16) (q lib "rosette/base/core/bool.rkt") (q 2529 . 7) (q 3864 . 7) (q 4034 . 5) (q 1752 . 28) (q lib "rosette/base/form/define.rkt") (q lib "rosette/query/debug.rkt") (q 3054 . 7) (q lib "rosette/base/core/union.rkt") (q lib "rosette/lib/synthax/form.rkt") (q lib "rosette/base/core/function.rkt") (q lib "rosette/base/core/type.rkt") (q 4862 . 7) (q 2724 . 10) (q lib "rosette/lib/synthax/core.rkt") (q lib "rosette/base/core/forall.rkt")) () (h ! (equal) ((c form c (c (? . 12) q debug)) q (1063 . 4)) ((c def c (c (? . 6) q clear-asserts!)) q (7626 . 2)) ((q def ((lib "rosette/query/core.rkt") current-solver)) q (4494 . 4)) ((c def c (c (? . 1) q expression?)) q (6813 . 3)) ((c def c (c (? . 0) q bitvector->integer)) c (? . 9)) ((c form c (c (? . 2) q verify)) q (315 . 3)) ((c def c (c (? . 0) q bvadd)) c (? . 13)) ((c def c (c (? . 0) q bvxor)) c (? . 7)) ((c def c (c (? . 0) q bvlshr)) c (? . 19)) ((c def c (c (? . 1) q term?)) q (6762 . 3)) ((c def c (c (? . 0) q sign-extend)) c (? . 8)) ((c def c (c (? . 4) q solution?)) q (5348 . 3)) ((c def c (c (? . 3) q solver-debug)) q (5179 . 3)) ((c def c (c (? . 0) q bvsge)) c (? . 10)) ((c form c (c (? . 1) q term)) q (6925 . 2)) ((c form c (c (? . 2) q synthesize)) q (408 . 10)) ((c def c (c (? . 0) q bvurem)) c (? . 5)) ((c def c (c (? . 0) q bv?)) q (1703 . 3)) ((c def c (c (? . 17) q type?)) q (7075 . 3)) ((c def c (c (? . 1) q clear-terms!)) q (7769 . 3)) ((c def c (c (? . 3) q solver-maximize)) c (? . 18)) ((c def c (c (? . 3) q solver-assert)) q (4675 . 4)) ((c form c (c (? . 2) q optimize)) q (611 . 14)) ((q def ((lib "rosette/solver/smt/z3.rkt") z3)) q (5320 . 2)) ((c def c (c (? . 4) q unsat?)) q (5479 . 3)) ((c form c (c (? . 21) q for/all*)) q (7389 . 2)) ((c def c (c (? . 0) q bvsrem)) c (? . 5)) ((c def c (c (? . 3) q gen:solver)) q (4593 . 2)) ((c def c (c (? . 6) q asserts)) q (7582 . 2)) ((c def c (c (? . 0) q bvsdiv)) c (? . 5)) ((c def c (c (? . 0) q bvand)) c (? . 7)) ((c def c (c (? . 6) q pc)) q (7553 . 2)) ((c form c (c (? . 6) q with-asserts)) q (7664 . 2)) ((c def c (c (? . 14) q union-contents)) q (7233 . 4)) ((c def c (c (? . 0) q zero-extend)) c (? . 8)) ((c def c (c (? . 4) q sat)) q (5549 . 4)) ((c form c (c (? . 1) q constant)) q (6991 . 2)) ((q def ((lib "rosette/query/eval.rkt") evaluate)) q (6024 . 4)) ((c form c (c (? . 11) q define-symbolic)) q (0 . 4)) ((c def c (c (? . 0) q bitvector->natural)) c (? . 9)) ((c def c (c (? . 0) q bitvector)) q (1304 . 3)) ((c def c (c (? . 0) q bvsmod)) c (? . 5)) ((c def c (c (? . 4) q model)) q (5778 . 3)) ((c def c (c (? . 0) q bvuge)) c (? . 10)) ((c def c (c (? . 0) q bveq)) c (? . 10)) ((q def ((lib "rosette/lib/angelic.rkt") choose*)) q (6591 . 3)) ((c def c (c (? . 0) q extract)) q (3736 . 5)) ((c form c (c (? . 11) q define-symbolic*)) q (83 . 4)) ((c def c (c (? . 0) q integer->bitvector)) q (4148 . 4)) ((c def c (c (? . 0) q bvor)) c (? . 7)) ((c def c (c (? . 0) q bvugt)) c (? . 10)) ((c def c (c (? . 3) q solver-check)) q (5108 . 3)) ((q form ((lib "rosette/base/core/safe.rkt") assert)) q (167 . 7)) ((c form c (c (? . 12) q define/debug)) q (989 . 5)) ((c def c (c (? . 0) q bvsle)) c (? . 10)) ((c def c (c (? . 1) q constant?)) q (6870 . 3)) ((c def c (c (? . 0) q bvult)) c (? . 10)) ((c def c (c (? . 3) q solver-shutdown)) q (5250 . 3)) ((c def c (c (? . 4) q core)) q (5897 . 3)) ((c def c (c (? . 0) q bvsub)) c (? . 13)) ((c def c (c (? . 0) q bvnot)) q (2463 . 3)) ((c def c (c (? . 3) q solver-clear)) q (4795 . 3)) ((c form c (c (? . 15) q choose)) q (6263 . 2)) ((c def c (c (? . 0) q bvslt)) c (? . 10)) ((q def ((lib "rosette/query/finitize.rkt") current-bitwidth)) q (1160 . 5)) ((c def c (c (? . 0) q bvudiv)) c (? . 5)) ((c def c (c (? . 3) q solver?)) q (4622 . 3)) ((c def c (c (? . 1) q term-cache)) q (7692 . 4)) ((c form c (c (? . 20) q define-synthax)) q (6291 . 6)) ((c def c (c (? . 14) q union?)) q (7181 . 3)) ((c form c (c (? . 1) q expression)) q (6954 . 2)) ((c def c (c (? . 0) q bv)) q (1479 . 5)) ((c def c (c (? . 16) q ~>)) q (4250 . 4)) ((c def c (c (? . 0) q bitvector?)) q (1423 . 3)) ((c def c (c (? . 0) q bvsgt)) c (? . 10)) ((q def ((lib "rosette/lib/render.rkt") render)) q (6647 . 4)) ((c form c (c (? . 15) q ??)) q (6127 . 7)) ((c def c (c (? . 16) q function?)) q (4390 . 3)) ((c def c (c (? . 17) q solvable?)) q (7126 . 3)) ((q form ((lib "rosette/lib/lift.rkt") define-lift)) q (7437 . 3)) ((c def c (c (? . 3) q solver-minimize)) c (? . 18)) ((c def c (c (? . 0) q bvashr)) c (? . 19)) ((c def c (c (? . 17) q type-of)) q (7019 . 3)) ((c def c (c (? . 20) q generate-forms)) q (6432 . 3)) ((c def c (c (? . 0) q bvule)) c (? . 10)) ((c def c (c (? . 4) q unsat)) q (5670 . 4)) ((c def c (c (? . 0) q concat)) q (3685 . 3)) ((c def c (c (? . 4) q sat?)) q (5411 . 3)) ((c form c (c (? . 21) q for/all)) q (7348 . 2)) ((c def c (c (? . 0) q bvneg)) q (2988 . 3)) ((c form c (c (? . 2) q solve)) q (294 . 2)) ((c def c (c (? . 0) q bvshl)) c (? . 19)) ((c def c (c (? . 20) q print-forms)) q (6519 . 3)) ((c def c (c (? . 0) q bvmul)) c (? . 13)) ((c def c (c (? . 16) q fv?)) q (4445 . 3))))
syntax
(define-symbolic id ...+ type)
 
  type : (and/c solvable? type?)
syntax
(define-symbolic* id ...+ type)
 
  type : (and/c solvable? type?)
syntax
(assert expr maybe-message)
 
maybe-message = 
              | expr
 
  expr : (or/c string? procedure?)
syntax
(solve expr)
syntax
(verify guarantee-expr)
(verify #:assume assume-expr #:guarantee guarantee-expr)
syntax
(synthesize
   #:forall input-expr
   maybe-assume
   #:guarantee guarantee-expr)
 
maybe-assume = 
             | #:assume assume-expr
 
  input-expr : (listof constant?)
syntax
(optimize
   maybe-minimize
   maybe-maximize
   #:guarantee guarantee-expr)
 
maybe-minimize = 
               | #:minimize minimize-expr
                  
maybe-maximize = 
               | #:maximize maximize-expr
 
  minimize-expr : (listof (or/c integer? real? bv?))
  maximize-expr : (listof (or/c integer? real? bv?))
syntax
(define/debug head body ...)
 
head = id
     | (id ...)
syntax
(debug [type ...+] expr)
 
  type : (and/c solvable? type? (not/c function?))
parameter
(current-bitwidth) -> (or/c #f positive-integer?)
(current-bitwidth k) -> void?
  k : (or/c #f positive-integer?)
 = 5
procedure
(bitvector size) -> bitvector?
  size : (and/c integer? positive? (not/c term?) (not/c union?))
procedure
(bitvector? v) -> boolean?
  v : any/c
procedure
(bv val size) -> bv?
  val : (and/c integer? (not/c term?) (not/c union?))
  size : (and/c (or/c bitvector? (and/c integer? positive?))
                (not/c term?) (not/c union?))
procedure
(bv? v) -> boolean?
  v : any/c
procedure
(bveq x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvslt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvult x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsle x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvule x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsgt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvugt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvuge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvnot x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvand x ...+) -> (bitvector n)
  x : (bitvector n)
(bvor x ...+) -> (bitvector n)
  x : (bitvector n)
(bvxor x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvshl x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvlshr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvashr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvneg x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvadd x ...+) -> (bitvector n)
  x : (bitvector n)
(bvsub x ...+) -> (bitvector n)
  x : (bitvector n)
(bvmul x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvsdiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvudiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsrem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvurem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsmod x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(concat x ...+) -> bv?
  x : bv?
procedure
(extract i j x) -> (bitvector (+ 1 (- i j)))
  i : integer?
  j : integer?
  x : (bitvector n)
procedure
(sign-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
(zero-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
procedure
(bitvector->integer x) -> integer?
  x : bv?
(bitvector->natural x) -> integer?
  x : bv?
procedure
(integer->bitvector i t) -> bv?
  i : integer?
  t : (or/c bitvector? union?)
procedure
(~> d ...+ r) -> function?
  d : (and/c solvable? (not/c function?))
  r : (and/c solvable? (not/c function?))
procedure
(function? v) -> boolean?
  v : any/c
procedure
(fv? v) -> boolean?
  v : any/c
parameter
(current-solver) -> solver?
(current-solver solver) -> void?
  solver : solver?
value
gen:solver : solver?
procedure
(solver? v) -> boolean?
  v : any/c
procedure
(solver-assert solver constraints) -> void?
  solver : solver?
  constraints : (listof boolean?)
procedure
(solver-clear solver) -> void?
  solver : solver?
procedure
(solver-minimize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
(solver-maximize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
procedure
(solver-check solver) -> solution?
  solver : solver?
procedure
(solver-debug solver) -> solution?
  solver : solver?
procedure
(solver-shutdown solver) -> void?
  solver : solver?
procedure
(z3) -> solver?
procedure
(solution? value) -> boolean?
  value : any/c
procedure
(sat? solution) -> boolean?
  solution : solution?
procedure
(unsat? solution) -> boolean?
  solution : solution?
procedure
(sat) -> solution?
(sat binding) -> solution?
  binding : (hash/c constant? any/c #:immutable #t)
procedure
(unsat) -> solution?
(unsat constraints) -> solution?
  constraints : (listof boolean?)
procedure
(model solution) -> (hash/c constant? any/c #:immutable #t)
  solution : (and/c sat? solution?)
procedure
(core solution) -> (or/c (listof (and/c constant? boolean?)) #f)
  solution : (and/c unsat? solution?)
procedure
(evaluate v solution) -> any/c
  v : any/c
  solution : (and/c solution? sat?)
syntax
(?? maybe-type)
 
maybe-type = 
           | type-expr
 
  type-expr : (and/c solvable? type? (not/c function?))
syntax
(choose expr ...+)
syntax
(define-synthax id
  ([pattern expr] ...+))
(define-synthax (id terminal ... k)
  #:base base-expr
  #:else else-expr)
procedure
(generate-forms solution) -> (listof syntax?)
  solution : solution?
procedure
(print-forms solution) -> void?
  solution : solution?
procedure
(choose* v ...+) -> any/c
  v : any/c
procedure
(render solution [font-size]) -> pict?
  solution : solution?
  font-size : natural/c = 16
procedure
(term? v) -> boolean?
  v : any/c
procedure
(expression? v) -> boolean?
  v : any/c
procedure
(constant? v) -> boolean?
  v : any/c
syntax
(term content type)
syntax
(expression op child ...+)
syntax
(constant id type)
procedure
(type-of v ...+) -> type?
  v : any/c
procedure
(type? v) -> boolean?
  v : any/c
procedure
(solvable? v) -> boolean?
  v : any/c
procedure
(union? v) -> boolean?
  v : any/c
procedure
(union-contents u)
 -> (listof (cons/c (and/c boolean? term?) (not/c union?)))
  u : union?
syntax
(for/all ([id val-expr]) body)
syntax
(for/all* ([id val-expr] ...+) body)
syntax
(define-lift id [(arg-type ...) racket-procedure-id])
(define-lift id [arg-type racket-procedure-id])
procedure
(pc) -> boolean?
procedure
(asserts) -> (listof boolean?)
procedure
(clear-asserts!) -> void?
syntax
(with-asserts expr)
parameter
(term-cache) -> hash?
(term-cache h) -> void?
  h : hash?
procedure
(clear-terms! [terms]) -> void?
  terms : (or/c #f (listof term?)) = #f
