6024
((3) 0 () 25 ((q lib "rosette/base/base.rkt") (q 2281 . 28) (q lib "rosette/base/core/term.rkt") (q 3779 . 16) (q lib "rosette/solver/solver.rkt") (q lib "rosette/base/core/type.rkt") (q 1514 . 7) (q lib "rosette/lib/synthax/core.rkt") (q lib "rosette/solver/solution.rkt") (q 5554 . 7) (q 1651 . 7) (q lib "rosette/lib/synthax/form.rkt") (q lib "rosette/base/core/forall.rkt") (q lib "rosette/base/form/define.rkt") (q lib "rosette/base/core/bool.rkt") (q lib "rosette/query/form.rkt") (q 3058 . 7) (q lib "rosette/base/core/union.rkt") (q lib "rosette/query/debug.rkt") (q lib "rosette/base/core/function.rkt") (q 3583 . 7) (q 4563 . 5) (q 1412 . 5) (q 3253 . 10) (q 4393 . 7)) () (h ! (equal) ((q def ((lib "rosette/lib/render.rkt") render)) q (7339 . 4)) ((c def c (c (? . 0) q bvsgt)) c (? . 1)) ((c def c (c (? . 19) q function?)) q (4919 . 3)) ((q def ((lib "rosette/lib/angelic.rkt") choose*)) q (7283 . 3)) ((c form c (c (? . 13) q define-symbolic*)) q (83 . 4)) ((c def c (c (? . 17) q union-contents)) q (7991 . 4)) ((c form c (c (? . 2) q expression)) q (7646 . 2)) ((c def c (c (? . 0) q bvuge)) c (? . 1)) ((c def c (c (? . 0) q bvugt)) c (? . 1)) ((c def c (c (? . 0) q bvult)) c (? . 1)) ((c def c (c (? . 2) q term?)) q (7454 . 3)) ((c def c (c (? . 0) q !)) q (1362 . 3)) ((c def c (c (? . 0) q bvudiv)) c (? . 3)) ((c def c (c (? . 4) q gen:solver)) q (5122 . 2)) ((c def c (c (? . 0) q exists)) c (? . 10)) ((c def c (c (? . 7) q generate-forms)) q (7124 . 3)) ((c def c (c (? . 0) q =>)) c (? . 6)) ((c def c (c (? . 2) q constant?)) q (7562 . 3)) ((c def c (c (? . 0) q bvurem)) c (? . 3)) ((c def c (c (? . 4) q solver-minimize)) c (? . 9)) ((c def c (c (? . 4) q solver?)) q (5151 . 3)) ((c def c (c (? . 0) q bvsge)) c (? . 1)) ((c def c (c (? . 14) q clear-asserts!)) q (8384 . 2)) ((c def c (c (? . 0) q bvsmod)) c (? . 3)) ((c form c (c (? . 15) q synthesize)) q (406 . 10)) ((c def c (c (? . 2) q expression?)) q (7505 . 3)) ((c def c (c (? . 0) q ||)) c (? . 22)) ((c def c (c (? . 5) q type?)) q (7833 . 3)) ((c form c (c (? . 18) q define/debug)) q (987 . 5)) ((c def c (c (? . 5) q type-of)) q (7777 . 3)) ((c def c (c (? . 4) q solver-check)) q (5800 . 3)) ((q def ((lib "rosette/query/core.rkt") current-solver)) q (5023 . 4)) ((c def c (c (? . 0) q <=>)) c (? . 6)) ((c def c (c (? . 4) q solver-push)) q (5324 . 3)) ((c def c (c (? . 0) q bveq)) c (? . 1)) ((c def c (c (? . 8) q unsat?)) q (6161 . 3)) ((q form ((lib "rosette/base/core/safe.rkt") assert)) q (167 . 7)) ((c def c (c (? . 0) q sign-extend)) c (? . 24)) ((c def c (c (? . 7) q print-forms)) q (7211 . 3)) ((c def c (c (? . 8) q unsat)) q (6394 . 4)) ((c def c (c (? . 2) q clear-terms!)) q (8560 . 3)) ((c def c (c (? . 0) q bvxor)) c (? . 16)) ((c form c (c (? . 12) q for*/all)) q (8147 . 2)) ((c def c (c (? . 4) q solver-maximize)) c (? . 9)) ((c def c (c (? . 8) q sat?)) q (6103 . 3)) ((c def c (c (? . 5) q solvable?)) q (7884 . 3)) ((c form c (c (? . 7) q define-synthax)) q (6983 . 6)) ((c def c (c (? . 0) q bvneg)) q (3517 . 3)) ((c def c (c (? . 8) q unknown)) q (6496 . 2)) ((c form c (c (? . 2) q term)) q (7617 . 2)) ((c def c (c (? . 0) q bvsdiv)) c (? . 3)) ((c def c (c (? . 0) q bitvector?)) q (1952 . 3)) ((q def ((lib "rosette/query/eval.rkt") evaluate)) q (6736 . 4)) ((c def c (c (? . 4) q solver-debug)) q (5871 . 3)) ((c def c (c (? . 8) q model)) q (6530 . 3)) ((c def c (c (? . 0) q forall)) c (? . 10)) ((c form c (c (? . 11) q choose)) q (6955 . 2)) ((c form c (c (? . 11) q ??)) q (6819 . 7)) ((c form c (c (? . 12) q for/all)) q (8106 . 2)) ((c def c (c (? . 0) q bvadd)) c (? . 20)) ((c form c (c (? . 13) q define-symbolic)) q (0 . 4)) ((c def c (c (? . 0) q bv)) q (2008 . 5)) ((c form c (c (? . 14) q with-asserts)) q (8422 . 2)) ((c form c (c (? . 15) q optimize)) q (609 . 14)) ((c def c (c (? . 0) q bvand)) c (? . 16)) ((c def c (c (? . 8) q sat)) q (6283 . 4)) ((c def c (c (? . 0) q bitvector)) q (1833 . 3)) ((c def c (c (? . 14) q pc)) q (8311 . 2)) ((c def c (c (? . 0) q integer->bitvector)) q (4677 . 4)) ((q def ((lib "rosette/solver/smt/z3.rkt") z3)) q (6012 . 2)) ((c def c (c (? . 0) q bvsle)) c (? . 1)) ((c def c (c (? . 4) q solver-assert)) q (5204 . 4)) ((c def c (c (? . 0) q bv?)) q (2232 . 3)) ((q def ((lib "rosette/query/finitize.rkt") current-bitwidth)) q (1158 . 5)) ((c def c (c (? . 0) q bitvector->integer)) c (? . 21)) ((c def c (c (? . 17) q union?)) q (7939 . 3)) ((q def ((lib "rosette/base/core/reflect.rkt") symbolics)) q (7711 . 3)) ((c def c (c (? . 0) q extract)) q (4265 . 5)) ((c def c (c (? . 0) q bvlshr)) c (? . 23)) ((c form c (c (? . 18) q debug)) q (1061 . 4)) ((c def c (c (? . 0) q bvor)) c (? . 16)) ((c def c (c (? . 19) q ~>)) q (4779 . 4)) ((c def c (c (? . 19) q fv?)) q (4974 . 3)) ((c def c (c (? . 0) q bvmul)) c (? . 20)) ((c def c (c (? . 8) q core)) q (6629 . 3)) ((c form c (c (? . 2) q constant)) q (7683 . 2)) ((c form c (c (? . 15) q verify)) q (313 . 3)) ((c def c (c (? . 0) q bvslt)) c (? . 1)) ((c def c (c (? . 0) q bvsrem)) c (? . 3)) ((c def c (c (? . 0) q bitvector->natural)) c (? . 21)) ((c form c (c (? . 14) q with-asserts-only)) q (8450 . 2)) ((c def c (c (? . 4) q solver-pop)) q (5390 . 4)) ((c def c (c (? . 0) q bvsub)) c (? . 20)) ((c def c (c (? . 0) q &&)) c (? . 22)) ((c def c (c (? . 0) q bvule)) c (? . 1)) ((c def c (c (? . 4) q solver-shutdown)) q (5942 . 3)) ((c def c (c (? . 4) q solver-clear)) q (5487 . 3)) ((c def c (c (? . 2) q term-cache)) q (8483 . 4)) ((c form c (c (? . 15) q solve)) q (292 . 2)) ((c def c (c (? . 0) q bvshl)) c (? . 23)) ((c def c (c (? . 0) q distinct?)) q (1302 . 3)) ((c def c (c (? . 0) q bvnot)) q (2992 . 3)) ((q form ((lib "rosette/lib/lift.rkt") define-lift)) q (8195 . 3)) ((c def c (c (? . 0) q bvashr)) c (? . 23)) ((c def c (c (? . 0) q concat)) q (4214 . 3)) ((c def c (c (? . 14) q asserts)) q (8340 . 2)) ((c def c (c (? . 0) q zero-extend)) c (? . 24)) ((c def c (c (? . 8) q unknown?)) q (6221 . 3)) ((c def c (c (? . 8) q solution?)) q (6040 . 3))))
syntax
(define-symbolic id ...+ type)
 
  type : (and/c solvable? type?)
syntax
(define-symbolic* id ...+ type)
 
  type : (and/c solvable? type?)
syntax
(assert expr maybe-message)
 
maybe-message = 
              | msg
 
  msg : (or/c string? procedure?)
syntax
(solve expr)
syntax
(verify guarantee-expr)
(verify #:assume assume-expr #:guarantee guarantee-expr)
syntax
(synthesize
   #:forall input-expr
   maybe-assume
   #:guarantee guarantee-expr)
 
maybe-assume = 
             | #:assume assume-expr
 
  input-expr : (listof constant?)
syntax
(optimize
   maybe-minimize
   maybe-maximize
   #:guarantee guarantee-expr)
 
maybe-minimize = 
               | #:minimize minimize-expr
                  
maybe-maximize = 
               | #:maximize maximize-expr
 
  minimize-expr : (listof (or/c integer? real? bv?))
  maximize-expr : (listof (or/c integer? real? bv?))
syntax
(define/debug head body ...)
 
head = id
     | (id ...)
syntax
(debug [type ...+] expr)
 
  type : (and/c solvable? type? (not/c function?))
parameter
(current-bitwidth) -> (or/c #f positive-integer?)
(current-bitwidth k) -> void?
  k : (or/c #f positive-integer?)
 = 5
procedure
(distinct? v ...) -> boolean?
  v : any/c
procedure
(! v) -> boolean?
  v : boolean?
procedure
(&& v ...) -> boolean?
  v : boolean?
(|| v ...) -> boolean?
  v : boolean?
procedure
(=> x y) -> boolean?
  x : boolean?
  y : boolean?
(<=> x y) -> boolean?
  x : boolean?
  y : boolean?
procedure
(forall vs body) -> boolean?
  vs : (listof constant?)
  body : boolean?
(exists vs body) -> boolean?
  vs : (listof constant?)
  body : boolean?
procedure
(bitvector size) -> bitvector?
  size : (and/c integer? positive? (not/c term?) (not/c union?))
procedure
(bitvector? v) -> boolean?
  v : any/c
procedure
(bv val size) -> bv?
  val : (and/c integer? (not/c term?) (not/c union?))
  size : (and/c (or/c bitvector? (and/c integer? positive?))
                (not/c term?) (not/c union?))
procedure
(bv? v) -> boolean?
  v : any/c
procedure
(bveq x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvslt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvult x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsle x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvule x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsgt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvugt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvuge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvnot x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvand x ...+) -> (bitvector n)
  x : (bitvector n)
(bvor x ...+) -> (bitvector n)
  x : (bitvector n)
(bvxor x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvshl x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvlshr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvashr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvneg x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvadd x ...+) -> (bitvector n)
  x : (bitvector n)
(bvsub x ...+) -> (bitvector n)
  x : (bitvector n)
(bvmul x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvsdiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvudiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsrem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvurem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsmod x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(concat x ...+) -> bv?
  x : bv?
procedure
(extract i j x) -> (bitvector (+ 1 (- i j)))
  i : integer?
  j : integer?
  x : (bitvector n)
procedure
(sign-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
(zero-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
procedure
(bitvector->integer x) -> integer?
  x : bv?
(bitvector->natural x) -> integer?
  x : bv?
procedure
(integer->bitvector i t) -> bv?
  i : integer?
  t : (or/c bitvector? union?)
procedure
(~> d ...+ r) -> function?
  d : (and/c solvable? (not/c function?))
  r : (and/c solvable? (not/c function?))
procedure
(function? v) -> boolean?
  v : any/c
procedure
(fv? v) -> boolean?
  v : any/c
parameter
(current-solver) -> solver?
(current-solver solver) -> void?
  solver : solver?
value
gen:solver : solver?
procedure
(solver? v) -> boolean?
  v : any/c
procedure
(solver-assert solver constraints) -> void?
  solver : solver?
  constraints : (listof boolean?)
procedure
(solver-push solver) -> void?
  solver : solver?
procedure
(solver-pop solver levels) -> void?
  solver : solver?
  levels : integer?
procedure
(solver-clear solver) -> void?
  solver : solver?
procedure
(solver-minimize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
(solver-maximize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
procedure
(solver-check solver) -> solution?
  solver : solver?
procedure
(solver-debug solver) -> solution?
  solver : solver?
procedure
(solver-shutdown solver) -> void?
  solver : solver?
procedure
(z3) -> solver?
procedure
(solution? value) -> boolean?
  value : any/c
procedure
(sat? value) -> boolean?
  value : any/c
procedure
(unsat? value) -> boolean?
  value : any/c
procedure
(unknown? value) -> boolean?
  value : any/c
procedure
(sat) -> sat?
(sat binding) -> sat?
  binding : (hash/c constant? any/c #:immutable #t)
procedure
(unsat) -> unsat?
(unsat constraints) -> unsat?
  constraints : (listof boolean?)
procedure
(unknown) -> unknown?
procedure
(model solution) -> (hash/c constant? any/c #:immutable #t)
  solution : sat?
procedure
(core solution) -> (or/c (listof (and/c constant? boolean?)) #f)
  solution : unsat?
procedure
(evaluate v solution) -> any/c
  v : any/c
  solution : sat?
syntax
(?? maybe-type)
 
maybe-type = 
           | type-expr
 
  type-expr : (and/c solvable? type? (not/c function?))
syntax
(choose expr ...+)
syntax
(define-synthax id
  ([pattern expr] ...+))
(define-synthax (id terminal ... k)
  #:base base-expr
  #:else else-expr)
procedure
(generate-forms solution) -> (listof syntax?)
  solution : solution?
procedure
(print-forms solution) -> void?
  solution : solution?
procedure
(choose* v ...+) -> any/c
  v : any/c
procedure
(render solution [font-size]) -> pict?
  solution : solution?
  font-size : natural/c = 16
procedure
(term? v) -> boolean?
  v : any/c
procedure
(expression? v) -> boolean?
  v : any/c
procedure
(constant? v) -> boolean?
  v : any/c
syntax
(term content type)
syntax
(expression op child ...+)
syntax
(constant id type)
procedure
(symbolics v) -> (listof constant?)
  v : any/c
procedure
(type-of v ...+) -> type?
  v : any/c
procedure
(type? v) -> boolean?
  v : any/c
procedure
(solvable? v) -> boolean?
  v : any/c
procedure
(union? v) -> boolean?
  v : any/c
procedure
(union-contents u)
 -> (listof (cons/c (and/c boolean? term?) (not/c union?)))
  u : union?
syntax
(for/all ([id val-expr]) body)
syntax
(for*/all ([id val-expr] ...+) body)
syntax
(define-lift id [(arg-type ...) racket-procedure-id])
(define-lift id [arg-type racket-procedure-id])
procedure
(pc) -> boolean?
procedure
(asserts) -> (listof boolean?)
procedure
(clear-asserts!) -> void?
syntax
(with-asserts expr)
syntax
(with-asserts-only expr)
parameter
(term-cache) -> hash?
(term-cache h) -> void?
  h : hash?
procedure
(clear-terms! [terms]) -> void?
  terms : (or/c #f (listof term?)) = #f
